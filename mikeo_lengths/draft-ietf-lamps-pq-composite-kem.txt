



LAMPS                                                       M. Ounsworth
Internet-Draft                                                   J. Gray
Intended status: Standards Track                                 Entrust
Expires: 20 April 2025                                           M. Pala
                                                             OpenCA Labs
                                                            J. Klaussner
                                                    Bundesdruckerei GmbH
                                                              S. Fluhrer
                                                           Cisco Systems
                                                         17 October 2024


Composite ML-KEM for Use in the Internet X.509 Public Key Infrastructure
                                and CMS
                draft-ietf-lamps-pq-composite-kem-latest

Abstract

   This document introduces a set of Key Encapsulation Mechanism (KEM)
   schemes that use pairs of cryptographic elements such as public keys
   and cipher texts to combine their security properties.  These schemes
   effectively mitigate risks associated with the adoption of post-
   quantum cryptography and are fully compatible with existing X.509,
   PKIX, and CMS data structures and protocols.  This document defines
   eleven specific pairwise combinations, namely ML-KEM Composite
   Schemes, that blend ML-KEM with traditional algorithms such as RSA-
   OAEP, ECDH, X25519, and X448.  For use within CMS, this document is
   intended to be coupled with the CMS KEMRecipientInfo mechanism in
   [I-D.housley-lamps-cms-kemri].  These combinations are tailored to
   meet security best practices and regulatory requirements.  Composite
   ML-KEM is applicable in any application that would otherwise use ML-
   KEM, but wants the protection against breaks or catastrophic bugs in
   ML-KEM.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://lamps-
   wg.github.io/draft-composite-kem/draft-ietf-lamps-pq-composite-
   kem.html#name-asn1-module.  Status information for this document may
   be found at https://datatracker.ietf.org/doc/draft-ietf-lamps-pq-
   composite-kem/.

   Discussion of this document takes place on the LAMPS Working Group
   mailing list (mailto:spams@ietf.org), which is archived at
   https://datatracker.ietf.org/wg/lamps/about/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/spams/.

   Source for this draft and an issue tracker can be found at
   https://github.com/lamps-wg/draft-composite-kem.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 20 April 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Changes in version -05
   2.  Introduction
     2.1.  Terminology
     2.2.  Composite Design Philosophy
     2.3.  Composite Key Encapsulation Mechanisms (KEMs)
       2.3.1.  Composite KeyGen
       2.3.2.  Promotion of RSA-OAEP into a KEM
       2.3.3.  Promotion of ECDH into a KEM
       2.3.4.  KEM Combiner
       2.3.5.  Composite Encap
       2.3.6.  Composite Decap
       2.3.7.  Decapsulation failure
   3.  Composite Key Structures
     3.1.  pk-CompositeKEM
     3.2.  CompositeKEMPublicKey
     3.3.  CompositeKEMPrivateKey
     3.4.  Encoding Rules
     3.5.  Key Usage Bits
   4.  Composite KEM Structures
     4.1.  kema-CompositeKEM
     4.2.  CompositeCiphertextValue
   5.  Algorithm Identifiers
     5.1.  Rationale for choices
     5.2.  Domain Separators
     5.3.  RSA-OAEP Parameters
   6.  Use in CMS
     6.1.  Underlying Components
     6.2.  RecipientInfo Conventions
     6.3.  Certificate Conventions
     6.4.  SMIMECapabilities Attribute Conventions
   7.  ASN.1 Module
   8.  IANA Considerations
     8.1.  Object Identifier Allocations
       8.1.1.  Module Registration - SMI Security for PKIX Module
               Identifier
       8.1.2.  Object Identifier Registrations - SMI Security for PKIX
               Algorithms
   9.  Security Considerations
     9.1.  KEM Combiner Security Analysis
       9.1.1.  Second pre-image resistance of componet KEMs
       9.1.2.  SHA3 vs HKDF-SHA2
       9.1.3.  Generifying this construction
       9.1.4.  Key Reuse
     9.2.  Policy for Deprecated and Acceptable Algorithms
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Samples
   Appendix B.  Fixed Component Algorithm Identifiers
   Appendix C.  Implementation Considerations
     C.1.  FIPS Certification
       C.1.1.  FIPS certification of Combiner Function
     C.2.  Backwards Compatibility
     C.3.  Decapsulation Requires the Public Key
   Appendix D.  Intellectual Property Considerations
   Appendix E.  Contributors and Acknowledgments
   Authors' Addresses

1.  Changes in version -05

   Interop-affecting changes:

   *  Fixed a bug in the definition of the Encaps() functions: KEMs,
      according to both RFC9180 and FIPS 203 should always return (ss,
      ct), but we had (ct, ss).

   *  Interoperable composite private key format requires component
      public keys (because public keys are required for decapsulation).

   *  Specified that the tradCT and tradPK inputs to the KEM combiner
      must be the raw values without the OCTET STRING wrapper.

   Editorial changes:

   *  Added an Implementation Consideration section explaining why
      private keys need to contain the public keys.

   *  Added a security consideration about key reuse.

   *  Added security considerations about SHA3-vs-HKDF-SHA2 and a
      warning against generifying this construction to other
      combinations of ciphers.

   *  Fixed a bug in the definition of the Encap() functions: KEMs,
      according to both RFC9180 and FIPS 203 should always return (ss,
      ct), but we had (ct, ss).

   *  Adjusted RSA-OAEP section to follow RFC8017 instead of RFC3560.
      Does not use the RSA-OAEP label.

   *  Aligning algorithm list with LAMPS WG on-list discussions and
      draft-openpgp-pqc

      -  ML-KEM-768 aligned with P-384 as per Quynh's OpenPGP
         presentation:
         https://datatracker.ietf.org/meeting/120/materials/slides-120-
         openpgp-pqc-with-nist-and-brainpool-curves

      -  Removing ML-KEM-512 combinations as per Sophie's
         recommendation: https://mailarchive.ietf.org/arch/msg/spasm/
         khasPf3y0_-Lq_0NtJe92unUw6o/

   *  Specified some options to use HKDF-SHA2, and some to use SHA3 to
      facilitate implementations that do not have easy access to SHA3
      outside the ML-KEM module.

   *  Tweaks to combiner function, thanks to Quynh and authors of draft-
      ietf-openpgp-PQC:

      -  Removed the counter.

      -  Un-twisted tradSS || mlkemSS to mlkemSS || tradSS as you would
         expect (thanks Quynh for pointing that this is allowed.)

   *  Enhanced the section about how to get this FIPS-certified.

   *  Updated OIDs and domain separators.

   *  ASN.1 module fixes (thanks Russ).

   Still to do in a future version:

   *  [ ] We need PEM samples … hackathon?  OQS friends?  David @ BC?
      The right format for samples is probably to follow the hackathon
      ... a Dilithium or ECDSA trust anchor certificate, a composite KEM
      end entity certificate, and a CMS EnvelopedData sample encrypted
      for that composite KEM certificate.

   *  [ ] Open question: do we need to include the ECDH, X25519, X448,
      and RSA public keys in the KDF?  X-Wing does, but previous
      versions of this spec do not.  In general existing ECC and RSA
      hardware decrypter implementations might not know their own public
      key.

2.  Introduction

   The advent of quantum computing poses a significant threat to current
   cryptographic systems.  Traditional cryptographic algorithms such as
   RSA-OAEP, ECDH and their elliptic curve variants are vulnerable to
   quantum attacks.  During the transition to post-quantum cryptography
   (PQC), there is considerable uncertainty regarding the robustness of
   both existing and new cryptographic algorithms.  While we can no
   longer fully trust traditional cryptography, we also cannot
   immediately place complete trust in post-quantum replacements until
   they have undergone extensive scrutiny and real-world testing to
   uncover and rectify potential implementation flaws.

   Unlike previous migrations between cryptographic algorithms, the
   decision of when to migrate and which algorithms to adopt is far from
   straightforward.  Even after the migration period, it may be
   advantageous for an entity's cryptographic identity to incorporate
   multiple public-key algorithms to enhance security.

   Cautious implementers may opt to combine cryptographic algorithms in
   such a way that an attacker would need to break all of them
   simultaneously to compromise the protected data.  These mechanisms
   are referred to as Post-Quantum/Traditional (PQ/T) Hybrids
   [I-D.ietf-pquip-pqt-hybrid-terminology].

   Certain jurisdictions are already recommending or mandating that PQC
   lattice schemes be used exclusively within a PQ/T hybrid framework.
   The use of Composite scheme provides a straightforward implementation
   of hybrid solutions compatible with (and advocated by) some
   governments and cybersecurity agencies [BSI2021].

   In addition, [BSI2021] specifically references this specification as
   a concrete example of hybrid X.509 certificates.

   A more recent example is [ANSSI2024], a document co-authored by
   French Cybersecurity Agency (ANSSI), Federal Office for Information
   Security (BSI), Netherlands National Communications Security Agency
   (NLNCSA), and Swedish National Communications Security Authority,
   Swedish Armed Forces which makes the following statement:

      “In light of the urgent need to stop relying only on quantum-
      vulnerable public-key cryptography for key establishment, the
      clear priority should therefore be the migration to post-quantum
      cryptography in hybrid solutions”

   This specification represents the straightforward implementation of
   the hybrid solutions called for by European cyber security agencies.

   PQ/T Hybrid cryptography can, in general, provide solutions to two
   migration problems:

   *  Algorithm strength uncertainty: During the transition period, some
      post-quantum signature and encryption algorithms will not be fully
      trusted, while also the trust in legacy public key algorithms will
      start to erode.  A relying party may learn some time after
      deployment that a public key algorithm has become untrustworthy,
      but in the interim, they may not know which algorithm an adversary
      has compromised.

   *  Ease-of-migration: During the transition period, systems will
      require mechanisms that allow for staged migrations from fully
      classical to fully post-quantum-aware cryptography.

   This document defines a specific instantiation of the PQ/T Hybrid
   paradigm called "composite" where multiple cryptographic algorithms
   are combined to form a single key encapsulation mechanism (KEM) key
   and ciphertext such that they can be treated as a single atomic
   algorithm at the protocol level.  Composite algorithms address
   algorithm strength uncertainty because the composite algorithm
   remains strong so long as one of its components remains strong.
   Concrete instantiations of composite KEM algorithms are provided
   based on ML-KEM, RSA-OAEP and ECDH.  Backwards compatibility is not
   directly covered in this document, but is the subject of
   Appendix C.2.

   Composite ML-KEM is intended for general applicability anywhere that
   key establishment or enveloped content encryption is used within PKIX
   or CMS structures.

2.1.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   This document is consistent with all terminology from
   [I-D.ietf-pquip-pqt-hybrid-terminology].  In addition, the following
   terms are used in this document:

   *COMBINER:* A combiner specifies how multiple shared secrets are
   combined into a single shared secret.

   *DER:* Distinguished Encoding Rules as defined in [X.690].

   *KEM:* A key encapsulation mechanism as defined in Section 2.3.

   *PKI:* Public Key Infrastructure, as defined in [RFC5280].

   *SHARED SECRET:* A value established between two communicating
   parties for use as cryptographic key material, but which cannot be
   learned by an active or passive adversary.  This document is
   concerned with shared secrets established via public key
   cryptographic operations.

2.2.  Composite Design Philosophy

   [I-D.ietf-pquip-pqt-hybrid-terminology] defines composites as:

      _Composite Cryptographic Element_: A cryptographic element that
      incorporates multiple component cryptographic elements of the same
      type in a multi-algorithm scheme.

   Composite keys, as defined here, follow this definition and should be
   regarded as a single key that performs a single cryptographic
   operation such as key generation, signing, verifying, encapsulating,
   or decapsulating -- using its internal sequence of component keys as
   if they form a single key.  This generally means that the complexity
   of combining algorithms can and should be handled by the
   cryptographic library or cryptographic module, and the single
   composite public key, private key, and ciphertext can be carried in
   existing fields in protocols such as PKCS#10 [RFC2986], CMP
   [RFC4210], X.509 [RFC5280], CMS [RFC5652], and the Trust Anchor
   Format [RFC5914].  In this way, composites achieve "protocol
   backwards-compatibility" in that they will drop cleanly into any
   protocol that accepts KEM algorithms without requiring any
   modification of the protocol to handle multiple keys.

2.3.  Composite Key Encapsulation Mechanisms (KEMs)

   We borrow here the definition of a key encapsulation mechanism (KEM)
   from [I-D.ietf-tls-hybrid-design], in which a KEM is a cryptographic
   primitive that consists of three algorithms:

   *  KeyGen() -> (pk, sk): A probabilistic key generation algorithm,
      which generates a public key pk and a secret key sk.

   *  Encap(pk) -> (ss, ct): A probabilistic encapsulation algorithm,
      which takes as input a public key pk and outputs a ciphertext ct
      and shared secret ss.  Note: this document uses Encap() to conform
      to [RFC9180], but [FIPS.204] uses Encaps().

   *  Decap(sk, ct) -> ss: A decapsulation algorithm, which takes as
      input a secret key sk and ciphertext ct and outputs a shared
      secret ss, or in some cases a distinguished error value.  Note:
      this document uses Decap() to conform to [RFC9180], but [FIPS.204]
      uses Decaps().

   The KEM interface defined above differs from both traditional key
   transport mechanism (for example for use with KeyTransRecipientInfo
   defined in [RFC5652]), and key agreement (for example for use with
   KeyAgreeRecipientInfo defined in [RFC5652]).

   The KEM interface was chosen as the interface for a composite key
   establishment because it allows for arbitrary combinations of
   component algorithm types since both key transport and key agreement
   mechanisms can be promoted into KEMs.  This specification uses the
   Post-Quantum KEM ML-KEM as specified in
   [I-D.ietf-lamps-kyber-certificates] and [FIPS.203].  For Traditional
   KEMs, this document uses the RSA-OAEP algorithm defined in [RFC3560],
   the Elliptic Curve Diffie-Hellman key agreement schemes ECDH defined
   in section 5.7.1.2 of [SP.800-56Ar3], and X25519 / X448 which are
   defined in [RFC8410].  A combiner function is used to combine the two
   component shared secrets into a single shared secret.

2.3.1.  Composite KeyGen

   The KeyGen() -> (pk, sk) of a composite KEM algorithm will perform
   the KeyGen() of the respective component KEM algorithms and it
   produces a composite public key pk as per Section 3.2 and a composite
   secret key sk as per Section 3.3.

   CompositeKEM.KeyGen():
     (compositePK[0], compositeSK[0]) = MLKEM.KeyGen()
     (compositePK[1], compositeSK[1]) = TradKEM.KeyGen()

     return (compositePK, compositeSK)

2.3.2.  Promotion of RSA-OAEP into a KEM

   The RSA Optimal Asymmetric Encryption Padding (OAEP), as defined in
   section 7.1 of [RFC8017] is a public key encryption algorithm used to
   transport key material from a sender to a receiver.  It is promoted
   into a KEM by having the sender generate a random 256 bit secret and
   encrypt it.

   RSAOAEPKEM.Encap(pkR):
     shared_secret = SecureRandom(ss_len)
     enc = RSAES-OAEP-ENCRYPT(pkR, shared_secret)

     return shared_secret, enc

   Note that the OAEP label L is left to its default value, which is the
   empty string as per [RFC8017].  The shared secret output by the
   overall composite KEM already binds a composite domain separator, so
   there is no need to also utilize the component domain separators.

   The value of ss_len as well as the RSA-OAEP parameters used within
   this specification can be found in Section 5.3.

   Decap(sk, ct) -> ss is accomplished in the analogous way.

   RSAOAEPKEM.Decap(skR, enc):
     shared_secret = RSAES-OAEP-DECRYPT(skR, enc)

     return shared_secret

   Note that, at least at the time of writing, the algorithm RSAOAEPKEM
   is not defined as a standalone algorithm within PKIX standards and it
   does not have an assigned algorithm OID, so it connot be used
   directly with CMS KEMRecipientInfo [RFC9629]; it is merely a building
   block for the composite algorithm.

2.3.3.  Promotion of ECDH into a KEM

   An elliptic curve Diffie-Hellman key agreement is promoted into a KEM
   Encap(pk) -> (ss, ct) using a simplified version of the DHKEM
   definition from [RFC9180].

   DHKEM.Encap(pkR):
     skE, pkE = GenerateKeyPair()
     shared_secret = DH(skE, pkR)
     enc = SerializePublicKey(pkE)

     return shared_secret, enc

   Decap(sk, ct) -> ss is accomplished in the analogous way.

   DHKEM.Decap(skR, enc):
     pkE = DeserializePublicKey(enc)
     shared_secret = DH(skR, pkE)

     return shared_secret

   This construction applies for all variants of elliptic curve Diffie-
   Hellman used in this specification: ECDH, X25519, and X448.

   The simplifications from the DHKEM definition in [RFC9180] is that
   since the ciphertext and receiver's public key are included
   explicitly in the composite KEM combiner, there is no need to
   construct the kem_context object, and since a domain separator is
   included explicitly in the composite KEM combiner there is no need to
   perform the labelled steps of ExtractAndExpand().

2.3.4.  KEM Combiner

   TODO: as per https://www.enisa.europa.eu/publications/post-quantum-
   cryptography-integration-study section 4.2, might need to specify
   behaviour in light of KEMs with a non-zero failure probability.

   The KEM combiner construction is as follows:

   Combiner(mlkemSS, tradSS, tradCT, tradPK, domSep) :

     return KDF(mlkemSS || tradSS || tradCT || tradPK || domSep)

                Figure 1: Generic KEM combiner construction

   where:

   *  KDF(message) represents a key derivation function suitable to the
      chosen KEMs according to {tab-kem-combiners}. All KDFs are
      specified with a fixed output length.

   *  mlkemSS is the shared secret from the ML-KEM componont.

   *  tradSS is the shared secret from the traditional component
      (elliptic curve or RSA).

   *  tradCT is the ciphertext from the traditional component (elliptic
      curve or RSA).

   *  tradPK is the public key of the traditional component (elliptic
      curve or RSA).

   *  domSep SHALL be the DER encoded value of the object identifier of
      the composite KEM algorithm as listed in Section 5.2.

   *  || represents concatenation.

   Each registered composite KEM algorithm specifies the choice of KDF,
   demSep to be used in Section 5 and Section 5.2 below.  Given that
   each composite KEM algorithm fully specifies the component
   algorithms, including for example the size of the RSA modulus, all
   inputs to the KEM combiner are fixed-size and thus do not require
   length-prefixing.  The CompositeKEM.Decap() specified in
   Section 2.3.6 adds further error handling to protect the KEM combiner
   from malicious inputs.

2.3.5.  Composite Encap

   Note that, at least at the time of writing, the algorithm DHKEM is
   not defined as a standalone algorithm within PKIX standards and it
   does not have an assigned algorithm OID, so it connot be used
   directly with CMS KEMRecipientInfo [RFC9629]; it is merely a building
   block for the composite algorithm.

   The Encap(pk) -> (ss, ct) of a composite KEM algorithm is defined as:

   CompositeKEM.Encap(pk):
     # Split the component public keys
     mlkemPK = pk[0]
     tradPK  = pk[1]

     # Perform the respective component Encap operations
     (mlkemCT, mlkemSS) = MLKEM.Encaps(mlkemPK)
     (tradCT, tradSS) = TradKEM.Encap(tradPK)

     # Combine
     # note that the order of the traditional and ML-KEM components
     # is flipped here in order to satisfy NIST SP800-56Cr2.
     ct = CompositeCiphertextValue(mlkemCT, tradCT)
     ss = Combiner(mlkemSS, tradSS, tradCT, tradPK, domSep)

     return (ss, ct)

   where Combiner(tradSS, mlkemSS, tradCT, tradPK, domSep) is defined in
   general in Section 2.3.4 with specific values for domSep per
   composite KEM algorithm in Section 5 and CompositeCiphertextValue is
   defined in Section 4.2.

2.3.6.  Composite Decap

   The Decap(sk, ct) -> ss of a composite KEM algorithm is defined as:

   CompositeKEM.Decap(ct, mlkemSK, tradSK):
     # split the component ciphertexts
     mlkemCT = ct[0]
     tradCT  = ct[1]

     # Perform the respective component Decap operations
     mlkemSS = MLKEM.Decaps(mlkemSK, mlkemCT)
     tradSS  = TradKEM.Decap(tradSK, tradCT)

     # Combine
     # note that the order of the traditional and ML-KEM components
     # is flipped here in order to satisfy NIST SP800-56Cr2.
     ss = Combiner(mlkemSS, tradSS, tradCT, tradPK, domSep)

     return ss

   where Combiner(tradSS, mlkemSS, tradCT, tradPK, domSep) is defined in
   general in Section 2.3.4 with specific values for domSep per
   composite KEM algorithm in Section 5.  CompositeCiphertextValue is
   defined in Section 4.2.

   Here the secret key values mlkemSK and tradSK may be interpreted as
   either literal secret key values, or as a handle to a cryptographic
   module which holds the secret key and is capable of performing the
   secret key operation.

   In order to properly achieve its security properties, the KEM
   combiner requires that all inputs are fixed-length.  Since each
   composite KEM algorithm fully specifies its component algorithms,
   including key sizes, all inputs are generally fixed-length, however
   some implementations may need to perform additional checking to
   handle certain error conditions.  In particular, the KEM combiner
   step should not be performed if either of the component
   decapsulations returned an error condition indicating malformed
   inputs -- for timing-invariance reasons, it is recommended to perform
   both decapsulation operations and check for errors afterwards to make
   it less easy for an attacker to tell which component failed.  Also,
   RSA-based composites MUST ensure that the modulus size (ie the size
   of tradCT and tradPK) matches that specified for the given composite
   KEM algorithm in Table 2; depending on the cryptographic library
   used, this check may be done by the library or may require an
   explicit check as part of the CompositeKEM.Decap() routine.

2.3.7.  Decapsulation failure

   Provided all inputs are well-formed, the key establishment procedure
   of ML-KEM will never explicitly fail.  Specifically, the ML-
   KEM.Encaps and ML-KEM.Decaps algorithms from [FIPS.203] will always
   output a value with the same data type as a shared secret key, and
   will never output an error or failure symbol.  However, it is
   possible (though extremely unlikely) that the process will fail in
   the sense that ML-KEM.Encaps and ML-KEM.Decaps will produce different
   outputs, even though both of them are behaving honestly and no
   adversarial interference is present.  In this case, the sender and
   recipient clearly did not succeed in producing a shared secret key.
   This event is called a decapsulation failure.  Estimates for the
   decapsulation failure probability (or rate) for each of the ML-KEM
   parameter sets are provided in Table 1 of [FIPS.203] and reproduced
   here in Table 1.

              +===============+============================+
              | Parameter set | Decapsulation failure rate |
              +===============+============================+
              | ML-KEM-512    | 2^(-139)                   |
              +---------------+----------------------------+
              | ML-KEM-768    | 2^(-164)                   |
              +---------------+----------------------------+
              | ML-KEM-1024   | 2^(-174)                   |
              +---------------+----------------------------+

               Table 1: ML-KEM decapsulation failure rates

   In the case of ML-KEM decapsulation failure, CompositeML-KEM MUST
   preserve the same behaviour and return a well-formed output.

3.  Composite Key Structures

3.1.  pk-CompositeKEM

   The following ASN.1 Information Object Class is a template to be used
   in defining all composite KEM public key types.

   pk-CompositeKEM {
     OBJECT IDENTIFIER:id, FirstPublicKeyType,
     SecondPublicKeyType} PUBLIC-KEY ::=
     {
       IDENTIFIER id
       KEY SEQUENCE {
        BIT STRING (CONTAINING FirstPublicKeyType)
        BIT STRING (CONTAINING SecondPublicKeyType)
       }
       PARAMS ARE absent
       CERT-KEY-USAGE { keyEncipherment }
     }

   As an example, the public key type pk-MLKEM512-ECDH-P256 is defined
   as:

   pk-MLKEM512-ECDH-P256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM512-ECDH-P256,
       OCTET STRING, ECPoint }

   The full set of key types defined by this specification can be found
   in the ASN.1 Module in Section 7.

3.2.  CompositeKEMPublicKey

   Composite public key data is represented by the following structure:

   CompositeKEMPublicKey ::= SEQUENCE SIZE (2) OF BIT STRING

   A composite key MUST contain two component public keys as SEQUENCE of
   two bit strings.  The order of the component keys is determined by
   the definition of the corresponding algorithm identifier as defined
   in section Section 5.

   Some applications may need to reconstruct the SubjectPublicKeyInfo
   objects corresponding to each component public key.  Table 2 in
   Section 5 provides the necessary mapping between composite and their
   component algorithms for doing this reconstruction.  This also
   motivates the design choice of SEQUENCE OF BIT STRING instead of
   SEQUENCE OF OCTET STRING; using BIT STRING allows for easier
   transcription between CompositeKEMPublicKey and SubjectPublicKeyInfo.

   When the CompositeKEMPublicKey must be provided in octet string or
   bit string format, the data structure is encoded as specified in
   Section 3.4.

   In order to maintain security properties of the composite,
   applications that use composite keys MUST always perform fresh key
   generations of both component keys and MUST NOT reuse existing key
   material.  See Section 9.1.4 for a discussion.

3.3.  CompositeKEMPrivateKey

   Use cases that require an inter-operable encoding for composite
   private keys, such as when private keys are carried in PKCS #12
   [RFC7292], CMP [RFC4210] or CRMF [RFC4211] MUST use the following
   structure.

   CompositeKEMPrivateKey ::= SEQUENCE SIZE (2) OF OneAsymmetricKey

   Each element is a OneAsymmetricKey [RFC5958] object for a component
   private key.

   The parameters field MUST be absent.

   The order of the component keys is the same as the order defined in
   Section 3.2 for the components of CompositeKEMPublicKey.

   Often, a CompositePrivateKey will be carried within a carrier format
   such as PKCS#8 which is itself a OneAsymmetricKey structure (version
   1 of which is also known as PrivateKeyInfo) [RFC5958], then a
   situation arises where we have CompositeKEMPrivateKey ::= SEQUENCE
   SIZE (2) OF OneAsymmetricKey inside another OneAsymmetricKey.  On the
   outer OneAsymmetricKey, the privateKeyAlgorithm field SHALL be set to
   the corresponding composite algorithm identifier defined according to
   Section 5, the privateKey field SHALL contain the
   CompositeKEMPrivateKey, and the publicKey field MUST NOT be present.
   As discussed in Appendix C.3, the ML-KEM private key encoding already
   includes a copy of the public key, so the publicKey field of the
   first OneAsymmetricKey remains OPTIONAL.  However, the public key of
   the traditional component, RSA or Elliptic Curve, is required as
   input to the KEM Combiner function, and is not typically carried
   within an RSA or Elliptic Curve private key.  Therefore the publicKey
   field of the second OneAsymmetricKey MUST contain the corresponding
   public key.  See Appendix C.3 for more discussion.  Which
   AlgorithmIDs to place into the component OneAsymmetricKeys is
   ambiguous; since
   OneAsymmetricKey.PrivateKeyAlgorithmIdentifier.AlgorithmID is not
   optional, producers MUST place something here and MAY either
   duplicate the composite AlgorithmID into both components, or MAY
   place the AlgorithmID of the component algorithm.  Parsers SHOULD
   ignore the component private key AlgorithmIDs and assume that the
   private keys are in the same order as specified in Table 2.

   In some use-cases the private keys that comprise a composite key may
   not be represented in a single structure or even be contained in a
   single cryptographic module; for example if one component is within
   the FIPS boundary of a cryptographic module and the other is not; see
   Appendix C.1 for more discussion.  The establishment of
   correspondence between public keys in a CompositeKEMPublicKey and
   private keys not represented in a single composite structure is
   beyond the scope of this document.

3.4.  Encoding Rules

   Many protocol specifications will require that the composite public
   key and composite private key data structures be represented by an
   octet string or bit string.

   When an octet string is required, the DER encoding of the composite
   data structure SHALL be used directly.

   CompositeKEMPublicKeyOs ::= OCTET STRING (CONTAINING CompositeKEMPublicKey ENCODED BY der)

   When a bit string is required, the octets of the DER encoded
   composite data structure SHALL be used as the bits of the bit string,
   with the most significant bit of the first octet becoming the first
   bit, and so on, ending with the least significant bit of the last
   octet becoming the last bit of the bit string.

   CompositeKEMPublicKeyBs ::= BIT STRING (CONTAINING CompositeKEMPublicKey ENCODED BY der)

3.5.  Key Usage Bits

   For protocols such as X.509 [RFC5280] that specify key usage along
   with the public key, then the composite public key associated with a
   composite KEM algorithm MUST contain only a keyEncipherment key
   usage, all other key usages MUST NOT be used.  This is because the
   composite public key can only be used in situations that are
   appropriate for both component algorithms, so even if the classical
   component key supports both signing and encryption, the post-quantum
   algorithms do not.

4.  Composite KEM Structures

4.1.  kema-CompositeKEM

   The ASN.1 algorithm object for a composite KEM is:

   kema-CompositeKEM {
     OBJECT IDENTIFIER:id,
       PUBLIC-KEY:publicKeyType }
       KEM-ALGORITHM ::= {
            IDENTIFIER id
            VALUE CompositeCiphertextValue
            PARAMS ARE absent
            PUBLIC-KEYS { publicKeyType }
           }

4.2.  CompositeCiphertextValue

   The compositeCipherTextValue is a SEQUENCE of the ciphertexts of the
   underlying component algorithms.  It is represented in ASN.1 as
   follows:

   CompositeCiphertextValue ::= SEQUENCE SIZE (2) OF OCTET STRING

   The order of the component ciphertexts is the same as the order
   defined in Section 3.2.

   Some of the design choices for the combiner, specifically to place
   tradSS first, and to allow tradCT || tradPK || domSep to be treated
   together as a FixedInfo block are made for the purposes of compliance
   with [SP.800-56Cr2]; see Appendix C.1 for more discussion.

   See Section 9.1 for further discussion of the security considerations
   of this KEM combiner.

5.  Algorithm Identifiers

   This table summarizes the list of composite KEM algorithms and lists
   the OID, two component algorithms, and the combiner function.

   EDNOTE: The OID referenced are TBD and MUST be used only for
   prototyping and replaced with the final IANA-assigned OIDs.

   TODO: OIDs to be replaced by IANA.

   <CompKEM>.1 is equal to 2.16.840.1.114027.80.5.2.1

   +=================+============+=========+===============+==========+
   |Composite KEM    |OID         |First    |Second         |KDF       |
   |                 |            |Algorithm|Algorithm      |          |
   +=================+============+=========+===============+==========+
   |id-              |<CompKEM>.21|MLKEM768 |RSA-OAEP 2048  |HKDF-     |
   |MLKEM768-RSA2048 |            |         |               |SHA256/256|
   +-----------------+------------+---------+---------------+----------+
   |id-              |<CompKEM>.22|MLKEM768 |RSA-OAEP 3072  |HKDF-     |
   |MLKEM768-RSA3072 |            |         |               |SHA256/256|
   +-----------------+------------+---------+---------------+----------+
   |id-              |<CompKEM>.23|MLKEM768 |RSA-OAEP 4096  |HKDF-     |
   |MLKEM768-RSA4096 |            |         |               |SHA256/256|
   +-----------------+------------+---------+---------------+----------+
   |id-              |<CompKEM>.24|MLKEM768 |X25519         |SHA3-256  |
   |MLKEM768-X25519  |            |         |               |          |
   +-----------------+------------+---------+---------------+----------+
   |id-MLKEM768-     |<CompKEM>.25|MLKEM768 |ECDH-P384      |HKDF-     |
   |ECDH-P384        |            |         |               |SHA384/384|
   +-----------------+------------+---------+---------------+----------+
   |id-MLKEM768-     |<CompKEM>.26|MLKEM768 |ECDH-          |HKDF-     |
   |ECDH-            |            |         |brainpoolp256r1|SHA384/384|
   |brainpoolP256r1  |            |         |               |          |
   +-----------------+------------+---------+---------------+----------+
   |id-MLKEM1024-    |<CompKEM>.27|MLKEM1024|ECDH-P384      |SHA3-512  |
   |ECDH-P384        |            |         |               |          |
   +-----------------+------------+---------+---------------+----------+
   |id-MLKEM1024-    |<CompKEM>.28|MLKEM1024|ECDH-          |SHA3-512  |
   |ECDH-            |            |         |brainpoolP384r1|          |
   |brainpoolP384r1  |            |         |               |          |
   +-----------------+------------+---------+---------------+----------+
   |id-              |<CompKEM>.29|MLKEM1024|X448           |SHA3-512  |
   |MLKEM1024-X448   |            |         |               |          |
   +-----------------+------------+---------+---------------+----------+

                      Table 2: Composite KEM key types

   Full specifications for the referenced algorithms can be found as
   follows:

   *  _ECDH_: There does not appear to be a single IETF definition of
      ECDH, so we refer to the following:

      -  _ECDH NIST_: SHALL be Elliptic Curve Cryptography Cofactor
         Diffie-Hellman (ECC CDH) as defined in section 5.7.1.2 of
         [SP.800-56Ar3].

      -  _ECDH BSI / brainpool_: SHALL be Elliptic Curve Key Agreement
         algorithm (ECKA) as defined in section 4.3.1 of [BSI-ECC]

   *  _ML-KEM_: [I-D.ietf-lamps-kyber-certificates] and [FIPS.203]

   *  _RSA-OAEP_: [RFC3560]

   *  _X25519 / X448_: [RFC8410]

   *  _HKDF_: [RFC5869].  Salt is not provided; ie the default salt (all
      zeroes of length HashLen) will be used.  In all cases, the output
      length of HKDF is the same as the block size of the underlying
      hash function, for example HKDF-SHA256/256 means HKDF-SHA256 with
      an output length L of 256 bits (32 octets).

   *  _SHA2_: [FIPS.180-4]

   *  _SHA3_: [FIPS.202]

5.1.  Rationale for choices

   *  Pair equivalent levels.

   *  NIST-P-384 is CNSA approved [CNSA2.0] for all classification
      levels.

   *  521 bit curve not widely used.

   A single invocation of SHA3 is known to behave as a dual-PRF, and
   thus is sufficient for use as a KDF, see Section 9.1, however SHA2 is
   not us must be wrapped in the HKDF construction.

   The lower security levels are provided with HKDF-SHA2 as the KDF in
   order to facilitate implementations that do not have easy access to
   SHA3 outside of the ML-KEM function.  Higher security levels are
   paired with SHA3 for computational efficiency, and the Edwards Curve
   (X25519 and X448) combinations are paired with SHA3 for compatibility
   with other similar spicifications.

5.2.  Domain Separators

   The KEM combiner defined in section Section 2.3.4 requires a domain
   separator domSep input.  The following table shows the HEX-encoded
   domain separator for each Composite KEM AlgorithmID; to use it, the
   value should be HEX-decoded and used in binary form.  The domain
   separator is simply the DER encoding of the composite algorithm OID.

    +===================================+============================+
    | Composite KEM AlgorithmID         | Domain Separator (in Hex   |
    |                                   | encoding)                  |
    +===================================+============================+
    | id-MLKEM768-RSA2048               | 060B6086480186FA6B50050215 |
    +-----------------------------------+----------------------------+
    | id-MLKEM768-RSA3072               | 060B6086480186FA6B50050216 |
    +-----------------------------------+----------------------------+
    | id-MLKEM768-RSA4096               | 060B6086480186FA6B50050217 |
    +-----------------------------------+----------------------------+
    | id-MLKEM768-ECDH-P384             | 060B6086480186FA6B50050218 |
    +-----------------------------------+----------------------------+
    | id-MLKEM768-ECDH-brainpoolP256r1  | 060B6086480186FA6B50050219 |
    +-----------------------------------+----------------------------+
    | id-MLKEM768-X25519                | 060B6086480186FA6B5005021A |
    +-----------------------------------+----------------------------+
    | id-MLKEM1024-ECDH-P384            | 060B6086480186FA6B5005021B |
    +-----------------------------------+----------------------------+
    | id-MLKEM1024-ECDH-brainpoolP384r1 | 060B6086480186FA6B5005021C |
    +-----------------------------------+----------------------------+
    | id-MLKEM1024-X448                 | 060B6086480186FA6B5005021D |
    +-----------------------------------+----------------------------+

            Table 3: Composite KEM fixedInfo Domain Separators

   EDNOTE: these domain separators are based on the prototyping OIDs
   assigned on the Entrust arc.  We will need to ask for IANA early
   allocation of these OIDs so that we can re-compute the domain
   separators over the final OIDs.

5.3.  RSA-OAEP Parameters

   Use of RSA-OAEP [RFC8017] within id-MLKEM768-RSA2048, id-
   MLKEM768-RSA3072, and id-MLKEM768-RSA4096 requires additional
   specification.

   First, a quick note on the choice of RSA-OAEP as the supported RSA
   encryption primitive.  RSA-KEM [RFC5990] is more straightforward to
   work with, but it has fairly limited adoption and therefore is of
   limited backwards compatibility value.  Also, while RSA-PKCS#1v1.5
   [RFC8017] is still everywhere, but hard to make secure and no longer
   FIPS-approved as of the end of 2023 [SP800-131Ar2], so it is of
   limited forwards value.  This leaves RSA-OAEP [RFC3560] as the
   remaining choice.

   The RSA component keys MUST be generated at the 2048-bit and 3072-bit
   security levels respectively.

   As with the other composite KEM algorithms, when id-MLKEM512-RSA2048
   or id-MLKEM512-RSA3072 is used in an AlgorithmIdentifier, the
   parameters MUST be absent.  The RSA-OAEP SHALL be instantiated with
   the following hard-coded parameters which are the same for both the
   2048 and 3072 bit security levels.

               +===================+======================+
               | RSAES-OAEP-params | Value                |
               +===================+======================+
               | hashAlgorithm     | id-sha2-256          |
               +-------------------+----------------------+
               | maskGenAlgorithm  | mgf1SHA256Identifier |
               +-------------------+----------------------+
               | pSourceAlgorithm  | pSpecifiedEmpty      |
               +-------------------+----------------------+
               | ss_len            | 256 bits             |
               +-------------------+----------------------+

                       Table 4: RSA-OAEP Parameters

   where:

   *  id-sha256 is defined in [RFC8017].

   *  mgf1SHA256Identifier is defined in [RFC4055], which refers to the
      MFG1 function defined in [RFC8017] appendix B.2.1.

   *  pSpecifiedEmpty is defined in [RFC8017] to indicate that the empty
      string is used for the label.

   Note: The mask length, according to [RFC8017], is k - hLen - 1, where
   k is the size of the RSA modulus.  Since the choice of hash function
   and the RSA key size is fixed for each composite algorithm,
   implementations could choose to pre-compute and hard-code the mask
   length.

6.  Use in CMS

   [EDNOTE: The convention in LAMPS is to specify algorithms and their
   CMS conventions in separate documents.  Here we have presented them
   in the same document, but this section has been written so that it
   can easily be moved to a standalone document.]

   Composite KEM algorithms MAY be employed for one or more recipients
   in the CMS enveloped-data content type [RFC5652], the CMS
   authenticated-data content type [RFC5652], or the CMS authenticated-
   enveloped-data content type [RFC5083].  In each case, the
   KEMRecipientInfo [RFC9629] is used with the chosen composite KEM
   Algorithm to securely transfer the content-encryption key from the
   originator to the recipient.

6.1.  Underlying Components

   When a particular Composite KEM OID is supported, a CMS
   implementation MUST support the corresponding KDF and key-encryption
   algorithms listed in Table 5, which have been chosen to preserve
   security and performance characteristics of each composite algorithm.

   +===================================+==========+====================+
   | Composite KEM OID                 | KDF      | Key Encryption     |
   |                                   |          | Alg                |
   +===================================+==========+====================+
   | id-MLKEM768-RSA2048               | SHA3-256 | id-aes128-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM768-RSA3072               | SHA3-256 | id-aes128-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM768-ECDH-P384             | SHA3-384 | id-aes256-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM768-ECDH-brainpoolP256r1  | SHA3-384 | id-aes256-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM768-X25519                | SHA3-384 | id-aes256-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM1024-ECDH-P384            | SHA3-512 | id-aes256-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM1024-ECDH-brainpoolP384r1 | SHA3-512 | id-aes256-Wrap     |
   +-----------------------------------+----------+--------------------+
   | id-MLKEM1024-X448                 | SHA3-512 | id-aes256-Wrap     |
   +-----------------------------------+----------+--------------------+

              Table 5: REQUIRED pairings for CMS KDF and WRAP

   In all cases above, the hash function used as a KDF produces a longer
   output than needed by the encryption algorithm, so the output SHALL
   be truncated to the correct length -- ie the leftmost significant
   bits are used.

   Note: id-aes256-Wrap is stronger than necessary for the MLKEM768
   combinations at the NIST level 3 192 bit security level, however id-
   aes256-Wrap was chosen because it has better general adoption than
   id-aes192-Wrap.

   where:

   *  id-sha3-* KDF instantiations are defined in
      [I-D.ietf-lamps-cms-sha3-hash].

   *  id-aes*-Wrap are defined in [RFC3394].

6.2.  RecipientInfo Conventions

   When a composite KEM Algorithm is employed for a recipient, the
   RecipientInfo alternative for that recipient MUST be
   OtherRecipientInfo using the KEMRecipientInfo structure [RFC9629].
   The fields of the KEMRecipientInfo MUST have the following values:

   version is the syntax version number; it MUST be 0.

   rid identifies the recipient's certificate or public key.

   kem identifies the KEM algorithm; it MUST contain one of the OIDs
   listed in Table 2.

   kemct is the ciphertext produced for this recipient; it contains the
   ct output from Encap(pk) of the KEM algorithm identified in the kem
   parameter.

   kdf identifies the key-derivation function (KDF).  Note that the KDF
   used for CMS RecipientInfo process MAY be different than the KDF used
   within the composite KEM Algorithm, which MAY be different than the
   KDFs (if any) used within the component KEMs of the composite KEM
   Algorithm.

   kekLength is the size of the key-encryption key in octets.

   ukm is an optional random input to the key-derivation function.

   wrap identifies a key-encryption algorithm used to encrypt the keying
   material.

   encryptedKey is the result of encrypting the keying material with the
   key-encryption key.  When used with the CMS enveloped-data content
   type [RFC5652], the keying material is a content-encryption key.
   When used with the CMS authenticated-data content type [RFC5652], the
   keying material is a message-authentication key.  When used with the
   CMS authenticated-enveloped-data content type [RFC5083], the keying
   material is a content-authenticated-encryption key.

6.3.  Certificate Conventions

   The conventions specified in this section augment RFC 5280 [RFC5280].

   The willingness to accept a composite KEM Algorithm MAY be signaled
   by the use of the SMIMECapabilities Attribute as specified in
   Section 2.5.2. of [RFC8551] or the SMIMECapabilities certificate
   extension as specified in [RFC4262].

   The intended application for the public key MAY be indicated in the
   key usage certificate extension as specified in Section 4.2.1.3 of
   [RFC5280].  If the keyUsage extension is present in a certificate
   that conveys a composite KEM public key, then the key usage extension
   MUST contain only the following value:

   keyEncipherment

   The digitalSignature and dataEncipherment values MUST NOT be present.
   That is, a public key intended to be employed only with a composite
   KEM algorithm MUST NOT also be employed for data encryption or for
   digital signatures.  This requirement does not carry any particular
   security consideration; only the convention that KEM keys be
   identified with the keyEncipherment key usage.

6.4.  SMIMECapabilities Attribute Conventions

   Section 2.5.2 of [RFC8551] defines the SMIMECapabilities attribute to
   announce a partial list of algorithms that an S/MIME implementation
   can support.  When constructing a CMS signed-data content type
   [RFC5652], a compliant implementation MAY include the
   SMIMECapabilities attribute that announces support for the RSA-OAEP
   Algorithm.

   The SMIMECapability SEQUENCE representing a composite KEM Algorithm
   MUST include the appropriate object identifier as per Table 2 in the
   capabilityID field.

7.  ASN.1 Module

   <CODE STARTS>

   Composite-MLKEM-2024
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-composite-mlkem-2024(TBDMOD) }

   DEFINITIONS IMPLICIT TAGS ::= BEGIN

   EXPORTS ALL;

   IMPORTS

   PUBLIC-KEY, AlgorithmIdentifier{}, SMIME-CAPS
     FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-algorithmInformation-02(58) }

   KEM-ALGORITHM
     FROM KEMAlgorithmInformation-2023
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-kemAlgorithmInformation-2023(99) }

   SubjectPublicKeyInfo
     FROM PKIX1Explicit-2009
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-pkix1-explicit-02(51) }

   OneAsymmetricKey
       FROM AsymmetricKeyPackageModuleV1
         { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
           pkcs-9(9) smime(16) modules(0)
           id-mod-asymmetricKeyPkgV1(50) }

   RSAPublicKey, ECPoint
     FROM PKIXAlgs-2009
       { iso(1) identified-organization(3) dod(6)
         internet(1) security(5) mechanisms(5) pkix(7) id-mod(0)
         id-mod-pkix1-algorithms2008-02(56) }

   ;


   --
   -- Object Identifiers
   --

   -- Defined in ITU-T X.690
   der OBJECT IDENTIFIER ::=
     {joint-iso-itu-t asn1(1) ber-derived(2) distinguished-encoding(1)}


   -- Just for testing, to be assigned by IANA
   id-raw-key OBJECT IDENTIFIER ::= {
      joint-iso-itu-t(2) country(16) us(840) organization(1)
      entrust(114027) algorithm(80) composite(8) raw(999) 1 }

   --
   -- Composite KEM basic structures
   --

   CompositeKEMPublicKey ::= SEQUENCE SIZE (2) OF BIT STRING

   CompositeKEMPublicKeyOs ::= OCTET STRING (CONTAINING
                                   CompositeKEMPublicKey ENCODED BY der)

   CompositeKEMPublicKeyBs ::= BIT STRING (CONTAINING
                                   CompositeKEMPublicKey ENCODED BY der)

   CompositeKEMPrivateKey ::= SEQUENCE SIZE (2) OF OneAsymmetricKey

   CompositeCiphertextValue ::= SEQUENCE SIZE (2) OF OCTET STRING

   RsaCompositeKemPublicKey ::= SEQUENCE {
           firstPublicKey BIT STRING (ENCODED BY id-raw-key),
           secondPublicKey BIT STRING (CONTAINING RSAPublicKey)
         }

   EcCompositeKemPublicKey ::= SEQUENCE {
           firstPublicKey BIT STRING (ENCODED BY id-raw-key),
           secondPublicKey BIT STRING (CONTAINING ECPoint)
         }

   EdCompositeKemPublicKey ::= SEQUENCE {
           firstPublicKey BIT STRING (ENCODED BY id-raw-key),
           secondPublicKey BIT STRING (ENCODED BY id-raw-key)
         }

   --
   -- Information Object Classes
   --

   pk-CompositeKEM {OBJECT IDENTIFIER:id, PublicKeyType}
     PUBLIC-KEY ::= {
       IDENTIFIER id
       KEY PublicKeyType
       PARAMS ARE absent
       CERT-KEY-USAGE { keyEncipherment }
     }

   kema-CompositeKEM {OBJECT IDENTIFIER:id,
       PUBLIC-KEY:publicKeyType }
       KEM-ALGORITHM ::= {
            IDENTIFIER id
            VALUE CompositeCiphertextValue
            PARAMS ARE absent
            PUBLIC-KEYS { publicKeyType }
            SMIME-CAPS { IDENTIFIED BY id }
         }



   --
   -- Composite KEM Algorithms
   --


   -- TODO: OID to be replaced by IANA
   id-MLKEM768-RSA2048 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 21 }

   pk-MLKEM768-RSA2048 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM512-RSA2048,
       RsaCompositeKemPublicKey }

   kema-MLKEM768-RSA2048 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM512-RSA2048,
         pk-MLKEM512-RSA2048 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-RSA3072 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 22 }

   pk-MLKEM768-RSA3072 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM512-RSA3072,
       RsaCompositeKemPublicKey }

   kema-MLKEM768-RSA3072 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM512-RSA3072,
         pk-MLKEM512-RSA3072 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-RSA4096 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 23 }

   pk-MLKEM768-RSA4096 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-RSA4096,
       RsaCompositeKemPublicKey }

   kema-MLKEM768-RSA4096 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-RSA4096,
         pk-MLKEM768-RSA4096 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM768-ECDH-P384 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 25 }

   pk-MLKEM768-ECDH-P384 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-ECDH-P384,
       EcCompositeKemPublicKey }

   kema-MLKEM768-ECDH-P384 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-ECDH-P384,
         pk-MLKEM768-ECDH-P384 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM768-ECDH-brainpoolP256r1 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 26 }

   pk-MLKEM768-ECDH-brainpoolP256r1 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-ECDH-brainpoolP256r1,
       EcCompositeKemPublicKey }

   kema-MLKEM768-ECDH-brainpoolP256r1 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-ECDH-brainpoolP256r1,
         pk-MLKEM768-ECDH-brainpoolP256r1 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM768-X25519 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 24 }

   pk-MLKEM768-X25519 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-X25519,
       EdCompositeKemPublicKey }

   kema-MLKEM768-X25519 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-X25519,
         pk-MLKEM768-X25519 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-ECDH-P384 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 27 }

   pk-MLKEM1024-ECDH-P384 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM1024-ECDH-P384,
       EcCompositeKemPublicKey }

   kema-MLKEM1024-ECDH-P384 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-ECDH-P384,
         pk-MLKEM1024-ECDH-P384 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-ECDH-brainpoolP384r1 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 28 }

   pk-MLKEM1024-ECDH-brainpoolP384r1 PUBLIC-KEY ::=
     pk-CompositeKEM{
       id-MLKEM1024-ECDH-brainpoolP384r1,
       EcCompositeKemPublicKey }

   kema-MLKEM1024-ECDH-brainpoolP384r1 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-ECDH-brainpoolP384r1,
         pk-MLKEM1024-ECDH-brainpoolP384r1 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-X448 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 29 }

   pk-MLKEM1024-X448 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM1024-X448,
       EdCompositeKemPublicKey }

   kema-MLKEM1024-X448 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-X448,
         pk-MLKEM1024-X448 }


   --
   -- Expand the S/MIME capabilities set used by CMS [RFC5911]
   --

   SMimeCaps SMIME-CAPS ::=
       { kema-MLKEM512-ECDH-P256-KMAC128.&smimeCaps |
         kema-MLKEM512-ECDH-brainpoolP256r1-KMAC128.&smimeCaps |
         kema-MLKEM512-X25519-KMAC128.&smimeCaps |
         kema-MLKEM512-RSA2048-KMAC128.&smimeCaps |
         kema-MLKEM512-RSA3072-KMAC128.&smimeCaps |
         kema-MLKEM768-ECDH-P256-KMAC256.&smimeCaps |
         kema-MLKEM768-ECDH-brainpoolP256r1-KMAC256.&smimeCaps |
         kema-MLKEM768-X25519-KMAC256.&smimeCaps |
         kema-MLKEM1024-ECDH-P384-KMAC256.&smimeCaps |
         kema-MLKEM1024-ECDH-brainpoolP384r1-KMAC256.&smimeCaps |
         kema-MLKEM1024-X448-KMAC256.&smimeCaps,
         ... }

   END

   <CODE ENDS>

8.  IANA Considerations

8.1.  Object Identifier Allocations

   EDNOTE to IANA: OIDs will need to be replaced in both the ASN.1
   module and in Table 2.

8.1.1.  Module Registration - SMI Security for PKIX Module Identifier

   *  Decimal: IANA Assigned - *Replace TBDMOD*

   *  Description: Composite-KEM-2023 - id-mod-composite-kems

   *  References: This Document

8.1.2.  Object Identifier Registrations - SMI Security for PKIX
        Algorithms

   *  id-raw-key

   *  Decimal: IANA Assigned

   *  Description: Designates a public key BIT STRING with no ASN.1
      structure.

   *  References: This Document

   *  id-MLKEM768-RSA2048

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-RSA2048

      -  References: This Document

   *  id-MLKEM768-RSA3072

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-RSA3072

      -  References: This Document

   *  id-MLKEM768-RSA4096

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-RSA4096

      -  References: This Document

   *  id-MLKEM768-ECDH-P384

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-ECDH-P384

      -  References: This Document

   *  id-MLKEM768-ECDH-brainpoolP256r1

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-ECDH-brainpoolP256r1

      -  References: This Document

   *  id-MLKEM768-X25519

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-X25519

      -  References: This Document

   *  id-MLKEM1024-ECDH-P384

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-ECDH-P384

      -  References: This Document

   *  id-MLKEM1024-ECDH-brainpoolP384r1

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-ECDH-brainpoolP384r1

      -  References: This Document

   *  id-MLKEM1024-X448

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-X448

      -  References: This Document

9.  Security Considerations

9.1.  KEM Combiner Security Analysis

   EDNOTE: the exact text to put here depends on the outcome of the CFRG
   KEM Combiners and X-Wing discussion.  If CFRG doesn't move fast
   enough for us, then we may need to leverage this security
   consideration directly on top of the X-Wing paper [X-Wing].

   The primary security property of the KEM combiner is that it
   preserves IND-CCA2 of the overall composite KEM so long as at least
   one component is IND-CCA2 X-Wing [GHP18].  Additionally, we also need
   to consider the case where one of the component algorithms is
   completely broken; that the private key is known to an attacker, or
   worse that the public key, private key, and ciphertext are
   maniputaled by the attacker.  In this case, we rely on the
   construction of the KEM combiner to ensure that the value of the
   other shared secret cannot be leaked or the combined shared secret
   predicted via manipulation of the broken algorithm.  The following
   sections continue this discussion.

9.1.1.  Second pre-image resistance of componet KEMs

   The notion of a second pre-image resistant KEM is defined in [X-Wing]
   being the property that it is computationally difficult to find two
   different ciphertexts c != c' that will decapsulate to the same
   shared secret under the same public key.  For the purposes of a
   hybrid KEM combiner, this property means that given two composite
   ciphertexts (c1, c2) and (c1', c2'), we must obtain a unique overall
   shared secret so long as either c1 != c1' or c2 != c2' -- i.e. the
   overall composite KEM is second pre-image resistant, and therefore
   IND-CCA2 secure so, long as one of the component KEMs is.

   In [X-Wing] it is proven that ML-KEM is a second pre-image resistant
   KEM and therefore the ML-KEM ciphertext can safely be omitted from
   the KEM combiner.  Note that this makes a fundamental assumption on
   ML-KEM remaining ciphertext second pre-image resistant, and thefore
   this formulation of KEM combiner does not fully protect against
   implementation errors in the ML-KEM component -- particularly around
   the ciphertext check step of the Fujisaki-Okamoto transform -- which
   could trivially lead to second ciphertext pre-image attacks that
   break the IND-CCA2 security of the ML-KEM component and of the
   overall composite KEM.  This could be more fully mitigated by binding
   the ML-KEM ciphertext in the combiner, but a design decision was made
   to settle for protection against algorithmic attacks and not
   implementation attacks against ML-KEM in order to increase
   performance.

   However, since neither RSA-OAEP nor ECDH guarantee second pre-image
   resistance at all, even in a correct implementation, these
   ciphertexts are bound to the key derivation in order to guarantee
   that c != c' will yield a unique ciphertext, and thus restoring
   second pre-image resistance to the overall composite KEM.

9.1.2.  SHA3 vs HKDF-SHA2

   In order to achieve the desired secutiy property that the composite
   KEM is IND-CCA2 whenever at least one of the component KEMs is, the
   KDF used in the KEM combiner needs to possess collision and second
   pre-image resistance with respect to each of its inputs
   independently; a property sometimes called "dual-PRF" [Aviram22].
   Collision and second-pre-image resistance protects against compromise
   of one component algorithm from resulting in the ability to construct
   multiple different ciphertexts which result in the same shared
   secret.  Pre-image resistance protects against compromise of one
   component algorithm being used to attack and learn the value of the
   other shared secret.

   SHA3 is known to have all of the necessary dual-PRF properties
   [X-Wing], but SHA2 does not and therefore all SHA2-based
   constructions MUST use SHA2 within an HMAC construction such as HKDF-
   SHA2 [GHP18].

9.1.3.  Generifying this construction

   It should be cleart that the security analsis of the presented KEM
   combiner construction relies heavily on the specific choices of
   component algorithms and combiner KDF, and this combiner construction
   SHOULD NOT by applied to any other combination of ciphers without
   performing the appropriate security analysis.

9.1.4.  Key Reuse

   TODO: does this section actually apply to composite KEMs, or only to
   composite signatures?

   When using single-algorithm cryptography, the best practice is to
   always generate fresh key material for each purpose, for example when
   renewing a certificate, or obtaining both a TLS and S/MIME
   certificate for the same device, however in practice key reuse in
   such scenarios is often not catestrophic to security and therefore
   often tolerated.  With composite keys we have a much stricter
   security requirement.  However this reasoning does not hold in the
   composite setting.  Consider an RSA key which already appears within
   a certificate and which is already being used to sign documents.  If
   a composite key is created which combines this existing RSA key with
   an ML-DSA key then an attacker is free to remove the ML-DSA component
   of any message signed with this key and instead present the document
   as if it had only been signed by the RSA key.  The scope of such
   "stripping attacks" is greatly reduced if composite keys never share
   key material with non-composite keys.  While this logic is less
   straight-forward for encryption operations involving KEM keys, it
   does apply to authentication modes involving KEMs.  A similar
   argument applies for two composite keys which share one component but
   not the other; as an example it becomes difficult for CAs and other
   relying parties to detect if a composite key contains a key which has
   been revoked due to key compromise since needing to keep lists of
   individual component keys is more complex than being able to search
   such lists for the composite key as a whole.

   For these reasons, applications using composite keys MUST perform
   fresh key generations for both components.  Failure to do so negates
   any non-separability properties
   [I-D.ietf-pquip-hybrid-signature-spectrums] of the composite and
   effectively reduces it to a

9.2.  Policy for Deprecated and Acceptable Algorithms

   Traditionally, a public key or certificate contains a single
   cryptographic algorithm.  If and when an algorithm becomes deprecated
   (for example, RSA-512, or SHA1), it is obvious that the public keys
   or certificates using that algorithm are to be considered revoked.

   In the composite model this is less obvious since implementers may
   decide that certain cryptographic algorithms have complementary
   security properties and are acceptable in combination even though one
   or both algorithms are deprecated for individual use.  As such, a
   single composite public key or certificate may contain a mixture of
   deprecated and non-deprecated algorithms.

   Since composite algorithms are registered independently of their
   component algorithms, their deprecation can be handled independently
   from that of their component algorithms.  For example a cryptographic
   policy might continue to allow id-MLKEM512-ECDH-P256 even after
   ECDH-P256 is deprecated.

   The composite KEM design specified in this document, and especially
   that of the KEM combiner specified in Section 2.3.4 means that the
   overall composite KEM algorithm should be considered to have the
   security strength of the strongest of its component algorithms; ie as
   long as one component algorithm remains strong, then the overall
   composite algorithm remains strong.

10.  References

10.1.  Normative References

   [BSI-ECC]  Federal Office for Information Security (BSI), "Technical
              Guideline BSI TR-03111: Elliptic Curve Cryptography.
              Version 2.10", 1 June 2018.

   [FIPS.180-4]
              National Institute of Standards and Technology (NIST),
              "FIPS Publication 180-4: Secure Hash Standard", August
              2015, <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.180-4.pdf>.

   [FIPS.202] National Institute of Standards and Technology (NIST),
              "SHA-3 Standard: Permutation-Based Hash and Extendable-
              Output Functions", August 2015,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.202.pdf>.

   [FIPS.203] National Institute of Standards and Technology (NIST),
              "Module-Lattice-based Key-Encapsulation Mechanism
              Standard", August 2024,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.203.pdf>.

   [I-D.ietf-lamps-cms-sha3-hash]
              Housley, R., "Use of the SHA3 One-way Hash Functions in
              the Cryptographic Message Syntax (CMS)", Work in Progress,
              Internet-Draft, draft-ietf-lamps-cms-sha3-hash-04, 16 May
              2024, <https://datatracker.ietf.org/doc/html/draft-ietf-
              lamps-cms-sha3-hash-04>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3394]  Schaad, J. and R. Housley, "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, DOI 10.17487/RFC3394,
              September 2002, <https://www.rfc-editor.org/info/rfc3394>.

   [RFC4055]  Schaad, J., Kaliski, B., and R. Housley, "Additional
              Algorithms and Identifiers for RSA Cryptography for use in
              the Internet X.509 Public Key Infrastructure Certificate
              and Certificate Revocation List (CRL) Profile", RFC 4055,
              DOI 10.17487/RFC4055, June 2005,
              <https://www.rfc-editor.org/info/rfc4055>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <https://www.rfc-editor.org/info/rfc5652>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC5958]  Turner, S., "Asymmetric Key Packages", RFC 5958,
              DOI 10.17487/RFC5958, August 2010,
              <https://www.rfc-editor.org/info/rfc5958>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8410]  Josefsson, S. and J. Schaad, "Algorithm Identifiers for
              Ed25519, Ed448, X25519, and X448 for Use in the Internet
              X.509 Public Key Infrastructure", RFC 8410,
              DOI 10.17487/RFC8410, August 2018,
              <https://www.rfc-editor.org/info/rfc8410>.

   [RFC8411]  Schaad, J. and R. Andrews, "IANA Registration for the
              Cryptographic Algorithm Object Identifier Range",
              RFC 8411, DOI 10.17487/RFC8411, August 2018,
              <https://www.rfc-editor.org/info/rfc8411>.

   [RFC9629]  Housley, R., Gray, J., and T. Okubo, "Using Key
              Encapsulation Mechanism (KEM) Algorithms in the
              Cryptographic Message Syntax (CMS)", RFC 9629,
              DOI 10.17487/RFC9629, August 2024,
              <https://www.rfc-editor.org/info/rfc9629>.

   [SP.800-56Ar3]
              National Institute of Standards and Technology (NIST),
              "Recommendation for Pair-Wise Key-Establishment Schemes
              Using Discrete Logarithm Cryptography", April 2018,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-56Ar3.pdf>.

   [SP.800-56Cr2]
              National Institute of Standards and Technology (NIST),
              "Recommendation for Key-Derivation Methods in Key-
              Establishment Schemes", August 2020,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-56Cr2.pdf>.

   [X.690]    ITU-T, "Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ISO/IEC 8825-1:2015, November 2015.

10.2.  Informative References

   [ANSSI2024]
              French Cybersecurity Agency (ANSSI), Federal Office for
              Information Security (BSI), Netherlands National
              Communications Security Agency (NLNCSA), and Swedish
              National Communications Security Authority, Swedish Armed
              Forces, "Position Paper on Quantum Key Distribution",
              n.d., <https://cyber.gouv.fr/sites/default/files/document/
              Quantum_Key_Distribution_Position_Paper.pdf>.

   [Aviram22] Yogev, E., "Practical (Post-Quantum) Key Combiners from
              One-Wayness and Applications to TLS", n.d.,
              <https://eprint.iacr.org/2022/065>.

   [BSI2021]  Federal Office for Information Security (BSI), "Quantum-
              safe cryptography - fundamentals, current developments and
              recommendations", October 2021,
              <https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/
              Publications/Brochure/quantum-safe-cryptography.pdf>.

   [CNSA2.0]  "Commercial National Security Algorithm Suite 2.0", n.d.,
              <https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/
              CSA_CNSA_2.0_ALGORITHMS_.PDF>.

   [FIPS-140-3-IG]
              National Institute of Standards and Technology (NIST),
              "Implementation Guidance for FIPS 140-3 and the
              Cryptographic Module Validation Program", July 2024,
              <https://csrc.nist.gov/csrc/media/Projects/cryptographic-
              module-validation-program/documents/fips%20140-3/
              FIPS%20140-3%20IG.pdf>.

   [GHP18]    Poettering, B., "KEM Combiners", 2018,
              <https://eprint.iacr.org/2018/024>.

   [I-D.housley-lamps-cms-kemri]
              Housley, R., Gray, J., and T. Okubo, "Using Key
              Encapsulation Mechanism (KEM) Algorithms in the
              Cryptographic Message Syntax (CMS)", Work in Progress,
              Internet-Draft, draft-housley-lamps-cms-kemri-02, 20
              February 2023, <https://datatracker.ietf.org/doc/html/
              draft-housley-lamps-cms-kemri-02>.

   [I-D.ietf-lamps-kyber-certificates]
              Turner, S., Kampanakis, P., Massimo, J., and B.
              Westerbaan, "Internet X.509 Public Key Infrastructure -
              Algorithm Identifiers for Kyber", Work in Progress,
              Internet-Draft, draft-ietf-lamps-kyber-certificates-01, 28
              March 2023, <https://datatracker.ietf.org/doc/html/draft-
              ietf-lamps-kyber-certificates-01>.

   [I-D.ietf-pquip-hybrid-signature-spectrums]
              Bindel, N., Hale, B., Connolly, D., and F. D, "Hybrid
              signature spectrums", Work in Progress, Internet-Draft,
              draft-ietf-pquip-hybrid-signature-spectrums-00, 24 May
              2024, <https://datatracker.ietf.org/doc/html/draft-ietf-
              pquip-hybrid-signature-spectrums-00>.

   [I-D.ietf-pquip-pqt-hybrid-terminology]
              D, F., P, M., and B. Hale, "Terminology for Post-Quantum
              Traditional Hybrid Schemes", Work in Progress, Internet-
              Draft, draft-ietf-pquip-pqt-hybrid-terminology-04, 10
              September 2024, <https://datatracker.ietf.org/doc/html/
              draft-ietf-pquip-pqt-hybrid-terminology-04>.

   [I-D.ietf-tls-hybrid-design]
              Stebila, D., Fluhrer, S., and S. Gueron, "Hybrid key
              exchange in TLS 1.3", Work in Progress, Internet-Draft,
              draft-ietf-tls-hybrid-design-04, 11 January 2022,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tls-
              hybrid-design-04>.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS #10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              DOI 10.17487/RFC2986, November 2000,
              <https://www.rfc-editor.org/info/rfc2986>.

   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", RFC 4210,
              DOI 10.17487/RFC4210, September 2005,
              <https://www.rfc-editor.org/info/rfc4210>.

   [RFC4211]  Schaad, J., "Internet X.509 Public Key Infrastructure
              Certificate Request Message Format (CRMF)", RFC 4211,
              DOI 10.17487/RFC4211, September 2005,
              <https://www.rfc-editor.org/info/rfc4211>.

   [RFC4262]  Santesson, S., "X.509 Certificate Extension for Secure/
              Multipurpose Internet Mail Extensions (S/MIME)
              Capabilities", RFC 4262, DOI 10.17487/RFC4262, December
              2005, <https://www.rfc-editor.org/info/rfc4262>.

   [RFC5083]  Housley, R., "Cryptographic Message Syntax (CMS)
              Authenticated-Enveloped-Data Content Type", RFC 5083,
              DOI 10.17487/RFC5083, November 2007,
              <https://www.rfc-editor.org/info/rfc5083>.

   [RFC5639]  Lochter, M. and J. Merkle, "Elliptic Curve Cryptography
              (ECC) Brainpool Standard Curves and Curve Generation",
              RFC 5639, DOI 10.17487/RFC5639, March 2010,
              <https://www.rfc-editor.org/info/rfc5639>.

   [RFC5914]  Housley, R., Ashmore, S., and C. Wallace, "Trust Anchor
              Format", RFC 5914, DOI 10.17487/RFC5914, June 2010,
              <https://www.rfc-editor.org/info/rfc5914>.

   [RFC5990]  Randall, J., Kaliski, B., Brainard, J., and S. Turner,
              "Use of the RSA-KEM Key Transport Algorithm in the
              Cryptographic Message Syntax (CMS)", RFC 5990,
              DOI 10.17487/RFC5990, September 2010,
              <https://www.rfc-editor.org/info/rfc5990>.

   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", RFC 6090,
              DOI 10.17487/RFC6090, February 2011,
              <https://www.rfc-editor.org/info/rfc6090>.

   [RFC7292]  Moriarty, K., Ed., Nystrom, M., Parkinson, S., Rusch, A.,
              and M. Scott, "PKCS #12: Personal Information Exchange
              Syntax v1.1", RFC 7292, DOI 10.17487/RFC7292, July 2014,
              <https://www.rfc-editor.org/info/rfc7292>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <https://www.rfc-editor.org/info/rfc7296>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC8551]  Schaad, J., Ramsdell, B., and S. Turner, "Secure/
              Multipurpose Internet Mail Extensions (S/MIME) Version 4.0
              Message Specification", RFC 8551, DOI 10.17487/RFC8551,
              April 2019, <https://www.rfc-editor.org/info/rfc8551>.

   [RFC9180]  Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, "Hybrid
              Public Key Encryption", RFC 9180, DOI 10.17487/RFC9180,
              February 2022, <https://www.rfc-editor.org/info/rfc9180>.

   [SP800-131Ar2]
              Barker, E. and A. Roginksy, "Transitioning the Use of
              Cryptographic Algorithms and Key Lengths", n.d.,
              <https://nvlpubs.nist.gov/nistpubs/specialpublications/
              nist.sp.800-131ar2.pdf>.

   [X-Wing]   Barbosa, M., Connolly, D., Duarte, J., Kaiser, A.,
              Schwabe, P., Varner, K., and B. Westerbaan, "X-Wing The
              Hybrid KEM You’ve Been Looking For", 9 January 2024,
              <https://eprint.iacr.org/2024/039.pdf>.

Appendix A.  Samples

   TBD

Appendix B.  Fixed Component Algorithm Identifiers

   The following table lists explicitly the DER encoded AlgorithmID that
   MUST be used when reconstructing SubjectPublicKeyInfo objects for
   each component public key, which may be required for example if
   cryptographic library requires the public key in this form in order
   to process each component algorithm.  The public key BIT STRING
   should be taken directly from the respective component of the
   CompositeKEMPublicKey.

        +===============+===================+====================+
        | Composite KEM | First AlgorithmID | Second AlgorithmID |
        +===============+===================+====================+
        | TODO          | TODO              | TODO               |
        +---------------+-------------------+--------------------+

                                 Table 6

   TODO: see https://github.com/lamps-wg/draft-composite-kem/issues/20

Appendix C.  Implementation Considerations

C.1.  FIPS Certification

   One of the primary design goals of this specification is for the
   overall composite algorithm to be able to be considered FIPS-approved
   even when one of the component algorithms is not.  Implementers
   seeking FIPS certification of a composite KEM algorithm where only
   one of the component algorithms has been FIPS-validated or FIPS-
   approved should credit the FIPS-validated component algorithm with
   full security strength, the non-FIPS-validated component algorithm
   with zero security, and the overall composite should be considered
   full strength and thus FIPS-approved.

   The authors wish to note that this gives composite algorithms great
   future utility both for future cryptographic migrations as well as
   bridging across jurisdictions; for example defining composite
   algorithms which combine FIPS cryptography with cryptography from a
   different national standards body.

C.1.1.  FIPS certification of Combiner Function

   TODO: update this to NIST SP 800-227, once it is published.

   One of the primary NIST documents which is relevant for certification
   of a composite algorithm is NIST SP.800-56Cr2 [SP.800-56Cr2] by using
   the allowed "hybrid" shared secret of the form Z' = Z || T.
   Compliance is acheived in the following way:

   SP.800-56Cr2 section 4 "One-Step Key Derivation" requires a counter
   which begins at the 4-byte value 0x00000001.  However, the counter is
   allowed to be omitted when the hash function is executed only once,
   as specified on page 159 of the FIPS 140-3 Implementation Guidance
   [FIPS-140-3-IG].

   The HKDF-SHA2 options can be certified under SP.800-56Cr2 One-Step
   Key Derivation Option 1: H(x) = hash(x).

   The SHA3 options can be certified under SP.800-56Cr2 One-Step Key
   Derivation Option 2: H(x) = HMAC-hash(salt, x) with the salt omitted.

C.2.  Backwards Compatibility

   As noted in the introduction, the post-quantum cryptographic
   migration will face challenges in both ensuring cryptographic
   strength against adversaries of unknown capabilities, as well as
   providing ease of migration.  The composite mechanisms defined in
   this document primarily address cryptographic strength, however this
   section contains notes on how backwards compatibility may be
   obtained.

   The term "ease of migration" is used here to mean that existing
   systems can be gracefully transitioned to the new technology without
   requiring large service disruptions or expensive upgrades.  The term
   "backwards compatibility" is used here to mean something more
   specific; that existing systems as they are deployed today can inter-
   operate with the upgraded systems of the future.

   These migration and interoperability concerns need to be thought
   about in the context of various types of protocols that make use of
   X.509 and PKIX with relation to key establishment and content
   encryption, from online negotiated protocols such as TLS 1.3
   [RFC8446] and IKEv2 [RFC7296], to non-negotiated asynchronous
   protocols such as S/MIME signed email [RFC8551], as well as myriad
   other standardized and proprietary protocols and applications that
   leverage CMS [RFC5652] encrypted structures.

C.3.  Decapsulation Requires the Public Key

   ML-KEM always requires the public key in order to perform various
   steps of the Fujisaki-Okamoto decapsulation [FIPS.203], and for this
   reason the private key encoding specified in FIPS 203 includes the
   public key.  Therefore it is not required to carry it in the
   OneAsymmetricKey.publicKey field, which remains optional, but is
   strictly speaking redundant since an ML-KEM public key can be parsed
   from an ML-KEM private key, and thus populating the
   OneAsymmetricKey.publicKey field would mean that two copies of the
   public key data are transmitted.

   With regard to the traditional algorithms, RSA or Elliptic Curve, in
   order to achieve the public-key binding property the KEM combiner
   used to form the composite KEM, the combiner requires the traditional
   public key as input to the KDF that derives the output shared secret.
   Therefore it is required to carry the public key within the
   respective OneAsymmetricKey.publicKey as per the private key encoding
   given in Section 3.3.  Implementers who choose to use a different
   private key encoding than the one specified in this document MUST
   consider how to provide the component public keys to the decapsulate
   routine.  While some implementations might contain routines to
   computationally derive the public key from the private key, it is not
   guaranteed that all implementations will support this; for this
   reason the interoparable composite private key format given in this
   document in Section 3.3 requires the public key of the traditional
   component to be included.

Appendix D.  Intellectual Property Considerations

   The following IPR Disclosure relates to this draft:

   https://datatracker.ietf.org/ipr/3588/

   EDNOTE TODO: Check with Max Pala whether this IPR actually applies to
   this draft.

Appendix E.  Contributors and Acknowledgments

   This document incorporates contributions and comments from a large
   group of experts.  The Editors would especially like to acknowledge
   the expertise and tireless dedication of the following people, who
   attended many long meetings and generated millions of bytes of
   electronic mail and VOIP traffic over the past year in pursuit of
   this document:

   Serge Mister (Entrust), Ali Noman (Entrust), Peter C.  (UK NCSC),
   Sophie Schmieg (Google), Deirdre Connolly (SandboxAQ), Falko Strenzke
   (MTG AG), Dan van Geest (Crypto Next), Piotr Popis (Enigma), and
   Douglas Stebila (University of Waterloo).

   We are grateful to all, including any contributors who may have been
   inadvertently omitted from this list.

   This document borrows text from similar documents, including those
   referenced below.  Thanks go to the authors of those documents.
   "Copying always makes things easier and less error prone" -
   [RFC8411].

Authors' Addresses

   Mike Ounsworth
   Entrust Limited
   2500 Solandt Road – Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: mike.ounsworth@entrust.com


   John Gray
   Entrust Limited
   2500 Solandt Road – Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: john.gray@entrust.com


   Massimiliano Pala
   OpenCA Labs
   New York City, New York,
   United States of America
   Email: director@openca.org


   Jan Klaussner
   Bundesdruckerei GmbH
   Kommandantenstr. 18
   10969 Berlin
   Germany
   Email: jan.klaussner@bdr.de


   Scott Fluhrer
   Cisco Systems
   Email: sfluhrer@cisco.com
